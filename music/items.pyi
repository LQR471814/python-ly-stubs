from collections.abc import Generator
from fractions import Fraction

from _typeshed import Incomplete
from typing import Iterator
from ly import lex as lex
from ly.document import Document as BaseDocument
from ly.lex import lilypond as lilypond
from ly.lex import scheme as scheme
from ly.lex.lilypond import Specifier
from ly.music.event import Events
from ly.node import WeakNode
from ly.pitch import Pitch

FractionalDuration = tuple[Fraction, Fraction]

class Item(WeakNode):
    document: BaseDocument
    tokens: lex.Token | list[lex.Token] | tuple[lex.Token, ...]
    token: lex.Token
    position: int
    def plaintext(self) -> str: ...
    def end_position(self) -> int: ...
    def events(self, e: Events, time: int, scaling: int) -> Incomplete: ...
    def length(self) -> Fraction | int: ...
    def iter_toplevel_items(self) -> Iterator[Item]: ...
    def iter_toplevel_items_include(self) -> Iterator[Item]: ...
    def music_parent(self) -> Music | None: ...
    def music_children(self, depth: int = ...) -> Iterator[Music]: ...
    def has_output(self) -> bool: ...

class Document(Item):
    document: BaseDocument
    def __init__(self, doc: BaseDocument) -> None: ...
    def node(self, position: int, depth: int = ...) -> Item: ...
    def music_events_til_position(self, position: int) -> list[tuple[Item, Item, int]]: ...
    def time_position(self, position: int) -> Fraction | None: ...
    def time_length(self, start: int, end: int) -> int: ...
    def substitute_for_node(self, node: Item) -> Item: ...
    def iter_music(self, node: Item | None = ...) -> Iterator[Item]: ...
    def get_included_document_node(self, node: Item) -> Document | None: ...
    def resolve_filename(self, filename: str) -> str | None: ...
    def get_music(self, filename: str) -> Document: ...

class Token(Item): ...
class Container(Item): ...
class Duration(Item): ...

class Durable(Item):
    duration: FractionalDuration

class Chord(Durable, Container): ...

class Unpitched(Durable):
    pitch: None

class Note(Durable):
    pitch: Pitch
    octave_token: lex.Token
    accidental_token: lex.Token
    octavecheck_token: lex.Token

class Skip(Durable): ...
class Rest(Durable): ...
class Q(Durable): ...
class DrumNote(Durable): ...

class Music(Container):
    def preceding(self, node: Item | None = ...) -> tuple[list[Item], int]: ...

class MusicList(Music):
    simultaneous: bool

class Tag(Music): ...

class Scaler(Music):
    scaling: int
    numerator: int
    denominator: int

class Grace(Music): ...

class AfterGrace(Music): ...

class PartCombine(Music): ...

class Relative(Music): ...
class Absolute(Music): ...
class Transpose(Music): ...

class Repeat(Music):
    def specifier(self) -> Specifier: ...
    def repeat_count(self) -> int: ...

class Alternative(Music): ...
class InputMode(Music): ...
class NoteMode(InputMode): ...
class ChordMode(InputMode): ...
class DrumMode(InputMode): ...
class FigureMode(InputMode): ...
class LyricMode(InputMode): ...

class LyricsTo(InputMode):
    def context_id(self) -> Incomplete: ...

class LyricText(Durable): ...
class LyricItem(Item): ...
class ChordSpecifier(Item): ...
class ChordItem(Item): ...

class Tremolo(Item):
    duration: FractionalDuration

class Translator(Item):
    def context(self): ...
    def context_id(self): ...

class Context(Translator, Music): ...
class Change(Translator): ...

class Tempo(Item):
    duration: FractionalDuration
    def fraction(self) -> Fraction: ...
    def text(self) -> Markup | Scheme | String | None: ...
    def tempo(self) -> list[int]: ...

class TimeSignature(Item):
    def measure_length(self) -> Fraction: ...
    def numerator(self) -> int: ...
    def fraction(self) -> Fraction: ...
    def beatstructure(self) -> Incomplete: ...

class Partial(Item):
    duration: FractionalDuration
    def partial_length(self) -> Fraction: ...

class Clef(Item):
    def specifier(self) -> Specifier: ...

class KeySignature(Item):
    def pitch(self) -> Pitch: ...
    def mode(self) -> str: ...

class PipeSymbol(Item): ...
class VoiceSeparator(Item): ...
class Postfix(Item): ...
class Tie(Item): ...

class Slur(Item):
    event: Incomplete

class PhrasingSlur(Item):
    event: Incomplete

class Beam(Item):
    event: Incomplete

class Dynamic(Item): ...
class Articulation(Item): ...
class StringTuning(Item): ...
class Keyword(Item): ...
class Command(Item): ...

class UserCommand(Music):
    def name(self) -> str: ...
    def value(self) -> str | None: ...

class Version(Item):
    def version_string(self) -> str: ...
    def version(self) -> tuple[int, ...]: ...

class Include(Item):
    def filename(self) -> str | None: ...

class Language(Item):
    language: lex.Token

class Markup(Item):
    def plaintext(self) -> str: ...

class MarkupCommand(Item):
    def plaintext(self) -> str: ...

class MarkupUserCommand(Item):
    def name(self) -> str: ...
    def value(self) -> str | None: ...

class MarkupScore(Item): ...

class MarkupList(Item):
    def plaintext(self) -> str: ...

class MarkupWord(Item):
    def plaintext(self) -> str: ...

class Assignment(Item):
    def name(self) -> str: ...
    def value(self) -> Item: ...

class Book(Container): ...
class BookPart(Container): ...
class Score(Container): ...
class Header(Container): ...
class Paper(Container): ...
class Layout(Container): ...
class Midi(Container): ...
class LayoutContext(Container): ...
class With(Container): ...

class Set(Item):
    def context(self) -> lex.Token | None: ...
    def property(self) -> lex.Token | None: ...
    def value(self) -> Item: ...

class Unset(Item):
    def context(self) -> lex.Token | None: ...
    def property(self) -> lex.Token | None: ...

class Override(Item):
    def context(self) -> lex.Token | None: ...
    def grob(self) -> lex.Token | None: ...

class Revert(Item):
    def context(self) -> lex.Token | None: ...
    def grob(self) -> lex.Token | None: ...

class Tweak(Item): ...
class PathItem(Item): ...

class String(Item):
    def plaintext(self) -> str: ...
    def value(self) -> str: ...

class Number(Item):
    def value(self) -> int | float | Fraction: ...

class Scheme(Item):
    def plaintext(self) -> str: ...
    def get_pair_ints(self) -> tuple[int, int] | None: ...
    def get_list_ints(self) -> list[int]: ...
    def get_int(self) -> int | None: ...
    def get_fraction(self) -> Fraction | int | None: ...
    def get_string(self) -> str: ...
    def get_ly_make_moment(self) -> Fraction | None: ...

class SchemeItem(Item): ...
class SchemeList(Container): ...
class SchemeQuote(Item): ...
class SchemeLily(Container): ...
